{
  "address": "0x7210DDE31B00Cc0187D4063FA5fbB85279FD6517",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "BLOCKS_PER_WEEK",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "FATE_PER_BLOCK",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "getFateAtBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_startBlock",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_fromBlock",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_toBlock",
          "type": "uint256"
        }
      ],
      "name": "getFatePerBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x6ff574473ada86d636167f311764f6e30e4e80cf1dc1a57f12a8a08c00cbeba2",
  "receipt": {
    "to": null,
    "from": "0x5a3D3Fe2c335f7BA1809d2919C7c63E5109456D9",
    "contractAddress": "0x7210DDE31B00Cc0187D4063FA5fbB85279FD6517",
    "transactionIndex": 0,
    "gasUsed": "542739",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa39ea77ced34afb1439d30f6da15fcefb8070ea906db6a055ab4024f972dac63",
    "transactionHash": "0x6ff574473ada86d636167f311764f6e30e4e80cf1dc1a57f12a8a08c00cbeba2",
    "logs": [],
    "blockNumber": 13550815,
    "cumulativeGasUsed": "542739",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "b7ddacc7c03173152a976502af032c1a",
  "metadata": "{\"compiler\":{\"version\":\"0.6.12+commit.27d51765\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BLOCKS_PER_WEEK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"FATE_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getFateAtBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fromBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toBlock\",\"type\":\"uint256\"}],\"name\":\"getFatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getFatePerBlock(uint256,uint256,uint256)\":{\"notice\":\"returns the average amount of FATE earned per block over any block period. If spanned over multiple weeks, a weighted average is calculated\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/fatex/EmissionSchedule.sol\":\"EmissionSchedule\"},\"evmVersion\":\"istanbul\",\"libraries\":{\"__CACHE_BREAKER__\":\"0x00000000d41867734bbee4c6863d9255b2b06ac1\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xcc78a17dd88fa5a2edc60c8489e2f405c0913b377216a5b26b35656b2d0dab52\",\"license\":\"MIT\"},\"contracts/fatex/EmissionSchedule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract EmissionSchedule {\\n    using SafeMath for uint;\\n\\n    // This is the emission schedule for each block for a given week\\n    uint[72] public FATE_PER_BLOCK = [\\n    36.00e18,\\n    36.51e18,\\n    37.02e18,\\n    37.54e18,\\n    38.06e18,\\n    38.60e18,\\n    39.14e18,\\n    39.69e18,\\n    40.24e18,\\n    40.81e18,\\n    41.38e18,\\n    41.96e18,\\n    42.55e18,\\n    72.00e18\\n    ];\\n\\n    // 30 blocks per minute, 60 minutes per hour, 24 hours per day, 7 days per week\\n    uint public constant BLOCKS_PER_WEEK = 30 * 60 * 24 * 7;\\n\\n    constructor() public {\\n    }\\n\\n    function getFateAtBlock(uint index) public view returns (uint) {\\n        if (index < 13) {\\n            // vesting occurs at an 80/20 rate for the first 13 weeks\\n            return FATE_PER_BLOCK[index] * 2 / 10;\\n        } else {\\n            return FATE_PER_BLOCK[index];\\n        }\\n    }\\n\\n    /// @notice returns the average amount of FATE earned per block over any block period. If spanned over multiple\\n    /// weeks, a weighted average is calculated\\n    function getFatePerBlock(\\n        uint _startBlock,\\n        uint _fromBlock,\\n        uint _toBlock\\n    )\\n    external\\n    view\\n    returns (uint) {\\n        if (_startBlock > _toBlock) {\\n            return 0;\\n        }\\n        if (_fromBlock < _startBlock) {\\n            _fromBlock = _startBlock;\\n        }\\n\\n        require(\\n            _fromBlock <= _toBlock,\\n            \\\"EmissionSchedule::getFatePerBlock: INVALID_RANGE\\\"\\n        );\\n\\n        uint startIndex = (_fromBlock - _startBlock) / BLOCKS_PER_WEEK;\\n        uint endIndex = (_toBlock - _startBlock) / BLOCKS_PER_WEEK;\\n        if (startIndex >= FATE_PER_BLOCK.length) {\\n            startIndex = FATE_PER_BLOCK.length - 1;\\n        }\\n        if (endIndex >= FATE_PER_BLOCK.length) {\\n            endIndex = FATE_PER_BLOCK.length - 1;\\n        }\\n\\n        if (startIndex < endIndex) {\\n            uint points = BLOCKS_PER_WEEK - ((_fromBlock - _startBlock) % BLOCKS_PER_WEEK);\\n            uint fatePerBlock = points * getFateAtBlock(startIndex);\\n\\n            for (uint i = startIndex + 1; i < endIndex; i++) {\\n                fatePerBlock = BLOCKS_PER_WEEK * getFateAtBlock(i);\\n            }\\n\\n            points = (_toBlock - _startBlock) % BLOCKS_PER_WEEK;\\n            fatePerBlock = fatePerBlock + (points * getFateAtBlock(endIndex));\\n\\n            return fatePerBlock / (_toBlock - _fromBlock);\\n        } else {\\n            // indices are the same\\n            assert(startIndex == endIndex);\\n            return getFateAtBlock(startIndex) * (_toBlock - _fromBlock);\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0x8fa6b0b8e6c55a6912d8ec6f61ebdf4bf8ba1dea755ab571e321f05850dcbba3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6102406040526801f399b1438a10000060809081526801faad938fcd83000060a052680201c175dc10f6000060c052680208f8df1ac42a000060e052680210304859775e000061010052680217aebf7d0a1400006101205268021f2d36a09cca000061014052680226cf34b69f4100006101605268022e7132cca1b80000610180526802365a3ec783b100006101a05268023e434ac265aa00006101c0526802464fddafb76400006101e05268024e7ff78f78df0000610200526803e733628714200000610220526100d590600090600e6100e8565b503480156100e257600080fd5b50610146565b8260488101928215610121579160200282015b8281111561012157825182906001600160481b03169055916020019190600101906100fb565b5061012d929150610131565b5090565b5b8082111561012d5760008155600101610132565b6102cb806101556000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80631f25440f1461005157806344ea9de514610080578063fb4c0e491461009d578063fc47e209146100c6575b600080fd5b61006e6004803603602081101561006757600080fd5b50356100ce565b60408051918252519081900360200190f35b61006e6004803603602081101561009657600080fd5b5035610113565b61006e600480360360608110156100b357600080fd5b5080359060208101359060400135610127565b61006e61025e565b6000600d8210156100fc57600a600083604881106100e857fe5b0154600202816100f457fe5b04905061010e565b6000826048811061010957fe5b015490505b919050565b6000816048811061012057fe5b0154905081565b60008184111561013957506000610257565b83831015610145578392505b8183111561019e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260308152602001806102666030913960400191505060405180910390fd5b62049d408484038190049085840304604882106101ba57604791505b604881106101c6575060475b8082101561023c5762049d40868603819006900360006101e5846100ce565b82029050600184015b8381101561020e576101ff816100ce565b62049d400291506001016101ee565b5062049d40888703069150610222836100ce565b820201868603818161023057fe5b04945050505050610257565b80821461024557fe5b848403610251836100ce565b02925050505b9392505050565b62049d408156fe456d697373696f6e5363686564756c653a3a67657446617465506572426c6f636b3a20494e56414c49445f52414e4745a26469706673582212203c15fe2047ce6601980cbda5bdef8fd9ec8bf953a4f150b61544c587f611d51664736f6c634300060c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c80631f25440f1461005157806344ea9de514610080578063fb4c0e491461009d578063fc47e209146100c6575b600080fd5b61006e6004803603602081101561006757600080fd5b50356100ce565b60408051918252519081900360200190f35b61006e6004803603602081101561009657600080fd5b5035610113565b61006e600480360360608110156100b357600080fd5b5080359060208101359060400135610127565b61006e61025e565b6000600d8210156100fc57600a600083604881106100e857fe5b0154600202816100f457fe5b04905061010e565b6000826048811061010957fe5b015490505b919050565b6000816048811061012057fe5b0154905081565b60008184111561013957506000610257565b83831015610145578392505b8183111561019e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260308152602001806102666030913960400191505060405180910390fd5b62049d408484038190049085840304604882106101ba57604791505b604881106101c6575060475b8082101561023c5762049d40868603819006900360006101e5846100ce565b82029050600184015b8381101561020e576101ff816100ce565b62049d400291506001016101ee565b5062049d40888703069150610222836100ce565b820201868603818161023057fe5b04945050505050610257565b80821461024557fe5b848403610251836100ce565b02925050505b9392505050565b62049d408156fe456d697373696f6e5363686564756c653a3a67657446617465506572426c6f636b3a20494e56414c49445f52414e4745a26469706673582212203c15fe2047ce6601980cbda5bdef8fd9ec8bf953a4f150b61544c587f611d51664736f6c634300060c0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getFatePerBlock(uint256,uint256,uint256)": {
        "notice": "returns the average amount of FATE earned per block over any block period. If spanned over multiple weeks, a weighted average is calculated"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 5342,
        "contract": "contracts/fatex/EmissionSchedule.sol:EmissionSchedule",
        "label": "FATE_PER_BLOCK",
        "offset": 0,
        "slot": "0",
        "type": "t_array(t_uint256)72_storage"
      }
    ],
    "types": {
      "t_array(t_uint256)72_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[72]",
        "numberOfBytes": "2304"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}